<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>合成大多米</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.55.2/phaser.min.js"></script>
    <style>
        body { margin: 0; background: #fdf6e3; display: flex; align-items: center; justify-content: center; height: 100vh; overflow: hidden; touch-action: none; }
        #score-ui { position: absolute; top: 5%; font-size: 24px; font-weight: bold; color: #657b83; z-index: 10; }
        #ui-layer { position: absolute; z-index: 100; text-align: center; background: rgba(253, 246, 227, 0.95); width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        button { padding: 15px 40px; font-size: 20px; cursor: pointer; background: #859900; color: white; border: none; border-radius: 10px; margin-top: 20px;}
        #game-container { width: 100vw; height: 100vh; max-width: 450px; }
    </style>
</head>
<body>

<div id="score-ui">得分: <span id="score-num">0</span></div>
<div id="ui-layer">
    <h1 style="color: #657b83;">合成大猫猫</h1>
    <p style="color: #93a1a1; font-size: 14px;">点屏幕左右移动，松开手指落下</p>
    <button id="start-btn">开始挑战</button>
</div>
<div id="game-container"></div>

<script>
let score = 0;
let isGameActive = false;
let currentCat = null;
let catsGroup;
let canInput = false;

const DEADLINE_Y = 120; 
const GAME_WIDTH = 450;
const GAME_HEIGHT = 750;
const BASE_SIZE = 200; // 内部处理图片时的标准基准大小

// 这里控制1级到9级猫猫的具体大小！
const LEVEL_SCALES =[
    0.25, // 1级缩放比例 (直径约50px)
    0.35, // 2级缩放比例 (直径约70px)
    0.50, // 3级缩放比例 (直径约100px)
    0.70, // 4级缩放比例 (直径约140px)
    0.90, // 5级缩放比例 (直径约180px)
    1.15, // 6级缩放比例 (直径约230px)
    1.45, // 7级缩放比例 (直径约290px)
    1.75, // 8级缩放比例 (直径约350px)
    2.10  // 9级缩放比例 (直径约420px - 接近满屏宽度)
];

const config = {
    type: Phaser.AUTO,
    width: GAME_WIDTH,
    height: GAME_HEIGHT,
    parent: 'game-container',
    backgroundColor: '#fdf6e3',
    scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
    physics: { default: 'arcade', arcade: { gravity: { y: 1200 }, debug: false } },
    scene: { preload: preload, create: create, update: update }
};

const game = new Phaser.Game(config);

function preload() {
    this.load.crossOrigin = 'anonymous';
    // 先把原始图片加载进来，命名为 raw_cat1 到 raw_cat9
    for (let i = 1; i <= 9; i++) {
        this.load.image(`raw_cat${i}`, `${i}.png`);
    }
}

function create() {
    const self = this;
    const colors =[0xff7f7f, 0x7fbf7f, 0x7f7fbf, 0xbfbf7f, 0xbf7fbf, 0x7fbfbf, 0xffb347, 0xb19cd9, 0xff6961];

    for (let i = 1; i <= 9; i++) {
        const rawKey = `raw_cat${i}`;
        const finalKey = `cat${i}`;

        if (this.textures.exists(rawKey) && this.textures.get(rawKey).key !== '__MISSING') {
            // 获取原图
            let srcImg = this.textures.get(rawKey).getSourceImage();
            
            // 创建一个隐藏的画板
            let canvas = document.createElement('canvas');
            canvas.width = BASE_SIZE;
            canvas.height = BASE_SIZE;
            let ctx = canvas.getContext('2d');
            
            // 1. 画一个圆，并限制接下来的图片只能画在这个圆里面 (裁剪效果)
            ctx.beginPath();
            ctx.arc(BASE_SIZE / 2, BASE_SIZE / 2, BASE_SIZE / 2, 0, Math.PI * 2);
            ctx.closePath();
            ctx.clip();
            
            // 2. 计算如何截取原图的最中间部分
            let minSide = Math.min(srcImg.width, srcImg.height); // 取长和宽里较短的一个作为正方形边长
            let startX = (srcImg.width - minSide) / 2;
            let startY = (srcImg.height - minSide) / 2;
            
            // 3. 把原图的中间部分画到我们的圆里，并强行缩放到 200x200 标准大小
            ctx.drawImage(srcImg, startX, startY, minSide, minSide, 0, 0, BASE_SIZE, BASE_SIZE);
            
            // 4. 把加工好的圆形图片存进游戏，名字叫 cat1, cat2...
            this.textures.addCanvas(finalKey, canvas);
        } else {
            // 如果图片加载失败（比如没传图），就画一个彩色的纯色圆球垫底
            const graphics = this.make.graphics({ x: 0, y: 0, add: false });
            graphics.fillStyle(colors[i-1], 1);
            graphics.fillCircle(BASE_SIZE / 2, BASE_SIZE / 2, BASE_SIZE / 2);
            graphics.generateTexture(finalKey, BASE_SIZE, BASE_SIZE);
        }
    }

    // 绘制失败警戒线 (红色虚线)
    const line = this.add.graphics();
    line.lineStyle(2, 0xff4444, 0.5);
    for (let i = 0; i < GAME_WIDTH; i += 15) { line.lineBetween(i, DEADLINE_Y, i + 8, DEADLINE_Y); }

    catsGroup = this.physics.add.group();

    // 碰撞与合成逻辑
    this.physics.add.collider(catsGroup, catsGroup, (o1, o2) => {
        if (o1.level === o2.level && o1.level < 9 && !o1.isMerging && !o2.isMerging) {
            o1.isMerging = o2.isMerging = true;
            const nextLvl = o1.level + 1;
            score += nextLvl * 10;
            document.getElementById('score-num').innerText = score;

            this.tweens.add({
                targets: [o1, o2], scale: 0, duration: 100,
                onComplete: () => {
                    const midX = (o1.x + o2.x) / 2;
                    const midY = (o1.y + o2.y) / 2;
                    o1.destroy(); o2.destroy();
                    spawnCat.call(self, midX, midY, nextLvl);
                }
            });
        }
    });

    // 触摸移动
    this.input.on('pointermove', (pointer) => {
        if (isGameActive && currentCat && canInput) {
            currentCat.x = Phaser.Math.Clamp(pointer.x, currentCat.displayWidth/2, GAME_WIDTH - currentCat.displayWidth/2);
        }
    });

    // 松开手指掉落
    this.input.on('pointerup', () => {
        if (isGameActive && currentCat && canInput) {
            dropCat.call(self);
        }
    });

    // 开始按钮逻辑
    const startBtn = document.getElementById('start-btn');
    startBtn.onclick = function(event) {
        event.stopPropagation();
        document.getElementById('ui-layer').style.display = 'none';
        isGameActive = true;
        score = 0;
        document.getElementById('score-num').innerText = "0";
        
        self.time.delayedCall(200, () => { prepareNextCat.call(self); });
    };
}

function update() {
    if (!isGameActive) return;

    catsGroup.getChildren().forEach(cat => {
        const aliveTime = Date.now() - cat.spawnTime;
        const isResting = Math.abs(cat.body.velocity.y) < 2 && Math.abs(cat.body.velocity.x) < 2;
        const catTopY = cat.y - (cat.displayHeight / 2);

        if (aliveTime > 3000 && isResting && catTopY < DEADLINE_Y) {
            isGameActive = false;
            alert("游戏结束！猫猫溢出啦！最终得分: " + score);
            location.reload(); 
        }
    });
}

function prepareNextCat() {
    if (!isGameActive) return;
    const level = Phaser.Math.Between(1, 3); // 随机生成1-3级的猫猫
    const scale = LEVEL_SCALES[level - 1]; // 获取对应等级的缩放比例
    
    currentCat = this.add.sprite(GAME_WIDTH / 2, 50, `cat${level}`);
    currentCat.level = level;
    currentCat.setScale(scale);
    canInput = true;
}

function dropCat() {
    canInput = false;
    const { x, y, level } = currentCat;
    currentCat.destroy();
    
    spawnCat.call(this, x, y, level);
    
    this.time.delayedCall(1000, () => {
        if (isGameActive) prepareNextCat.call(this);
    });
}

function spawnCat(x, y, level) {
    const scale = LEVEL_SCALES[level - 1];
    
    const cat = catsGroup.create(x, y, `cat${level}`);
    cat.level = level;
    cat.spawnTime = Date.now();
    
    // 物理引擎设定
    cat.setScale(scale);
    // 核心物理：设定碰撞范围是完美的圆形（基于200像素基准，半径是100）
    cat.setCircle(100); 
    cat.setBounce(0.15); // 微小的弹性，显得有果冻感
    cat.setCollideWorldBounds(true);
    
    return cat;
}
</script>
</body>
</html>

